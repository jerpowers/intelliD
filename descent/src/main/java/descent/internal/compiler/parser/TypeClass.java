package descent.internal.compiler.parser;

import static descent.internal.compiler.parser.DYNCAST.DYNCAST_IDENTIFIER;
import static descent.internal.compiler.parser.MATCH.MATCHconst;
import static descent.internal.compiler.parser.MATCH.MATCHconvert;
import static descent.internal.compiler.parser.MATCH.MATCHexact;
import static descent.internal.compiler.parser.MATCH.MATCHnomatch;
import static descent.internal.compiler.parser.TOK.TOKdotexp;
import static descent.internal.compiler.parser.TOK.TOKdottype;
import static descent.internal.compiler.parser.TOK.TOKimport;
import static descent.internal.compiler.parser.TOK.TOKtype;
import static descent.internal.compiler.parser.TY.Tclass;
import static descent.internal.compiler.parser.TY.Tinstance;
import static descent.internal.compiler.parser.TY.Tpointer;
import static descent.internal.compiler.parser.TY.Tsarray;
import static descent.internal.compiler.parser.TY.Tvoid;
import descent.core.IJavaElement__Marker;
import descent.core.compiler.IProblem;
import descent.internal.compiler.parser.ast.IASTVisitor;


public class TypeClass extends Type {

	public ClassDeclaration sym;

	public TypeClass(ClassDeclaration sym) {
		super(TY.Tclass);
		this.sym = sym;
	}

	@Override
	public void accept0(IASTVisitor visitor) {
		visitor.visit(this);
		visitor.endVisit(this);
	}
	
	@Override
	public boolean builtinTypeInfo(SemanticContext context) {
	    /* This is statically put out with the ClassInfo, so
	     * claim it is built in so it isn't regenerated by each module.
	     */
		if (context.isD1()) {
			return true;
		} else {
		    return mod != 0 ? false : true;
		}
	}

	@Override
	public boolean checkBoolean(SemanticContext context) {
		return true;
	}
	
	@Override
	public MATCH constConv(Type to, SemanticContext context) {
		if (equals(to))
			return MATCHexact;
		if (ty == to.ty && sym == ((TypeClass) to).sym && to.mod == MODconst)
			return MATCHconst;
		return MATCHnomatch;
	}

	@Override
	public MATCH deduceType(Scope sc, Type tparam,
			TemplateParameters parameters, Objects dedtypes,
			SemanticContext context) {
		/* If this class is a template class, and we're matching
		 * it against a template instance, convert the class type
		 * to a template instance, too, and try again.
		 */
		TemplateInstance ti = sym.parent.isTemplateInstance();

		if (tparam != null && tparam.ty == Tinstance) {
			if (ti != null && ti.toAlias(context) == sym) {
				TypeInstance t = new TypeInstance(null, 0, ti);
				return t.deduceType(sc, tparam, parameters, dedtypes, context);
			}

			/* Match things like:
			 *  S!(T).foo
			 */
			TypeInstance tpi = (TypeInstance) tparam;
			if (size(tpi.idents) != 0) {
				IdentifierExp id = tpi.idents.get(tpi.idents.size() - 1);
				if (id.dyncast() == DYNCAST_IDENTIFIER && equals(sym.ident, id)) {
					Type tparent = sym.parent.getType(context);
					if (tparent != null) {
						/* Slice off the .foo in S!(T).foo
						 */
						// TODO semantic
						// tpi.idents.size()--;
						MATCH m = tparent.deduceType(sc, tpi, parameters,
								dedtypes, context);
						// TODO semantic
						// tpi.idents.size()++;
						return m;
					}
				}
			}
		}

		// Extra check
		if (tparam != null && tparam.ty == Tclass) {
			TypeClass tp = (TypeClass) tparam;

			return implicitConvTo(tp, context);
		}
		return super.deduceType(sc, tparam, parameters, dedtypes, context);
	}

	@Override
	public Expression defaultInit(char[] filename, int lineNumber, SemanticContext context) {
		Expression e;
		e = new NullExp(filename, lineNumber);
		e.type = this;
		return e;
	}

	@Override
	public Expression dotExp(Scope sc, Expression e, IdentifierExp ident,
			SemanticContext context) {
		VarDeclaration v;
		Dsymbol s;
		DotVarExp de;
		Declaration d;

		boolean gotoL1 = false;
		if (e.op == TOKdotexp) {
			DotExp de_ = (DotExp) e;

			if (de_.e1.op == TOKimport) {
				ScopeExp se = (ScopeExp) de_.e1;

				s = se.sds.search(e.filename, e.lineNumber,  ident, 0, context);
				e = de_.e1;
				//goto L1;
				gotoL1 = true;
			} else {
				s = sym.search(e.filename, e.lineNumber,  ident, 0, context);
			}
		} else {
			// Ident may be null if completing (Foo).|
			if (ident == null) {
				return e;
			}
			s = sym.search(e.filename, e.lineNumber,  ident, 0, context);
		}

		if (equals(ident, Id.tupleof) && !gotoL1) {
			/* Create a TupleExp
			 */
			e = e.semantic(sc, context);	// do this before turning on noaccesscheck
			
			// Added for Descent
			sym = (ClassDeclaration) sym.unlazy(context);
			
			Expressions exps = new Expressions(sym.fields.size());
			for (VarDeclaration v_ : sym.fields) {
				Expression fe = new DotVarExp(e.filename, e.lineNumber,  e, v_);
				exps.add(fe);
			}
			e = new TupleExp(e.filename, e.lineNumber,  exps);
			sc = sc.push();
			sc.noaccesscheck = 1;
			e = e.semantic(sc, context);
			sc.pop();
			return e;
		}

		gotoL1 = true;
		// L1:
		while(gotoL1) {
			gotoL1 = false;
			
			if (null == s) {
				// See if it's a base class
				ClassDeclaration cbase;
				for (cbase = sym.baseClass; null != cbase; cbase = cbase.baseClass) {
					if (equals(ident, cbase.ident)) {
						e = new DotTypeExp(null, 0, e, cbase, context);
						return e;
					}
				}
	
				if (equals(ident, Id.classinfo)) {
					Type t;
	
					if (context.ClassDeclaration_classinfo == null) {
						throw new IllegalStateException(
								"assert(ClassDeclaration.classinfo);");
					}
					t = context.ClassDeclaration_classinfo.type;
					if (e.op == TOKtype || e.op == TOKdottype) {
						/* 
						 * For type.classinfo, we know the classinfo at compile time.
						 */
						if (sym.vclassinfo == null) {
							sym.vclassinfo = new ClassInfoDeclaration(sym, context);
						}
						e = new VarExp(e.filename, e.lineNumber,  sym.vclassinfo);
						e = e.addressOf(sc, context);
						e.type = t; // do this so we don't get redundant dereference
					} else {
					    /* 
					     * For class objects, the classinfo reference is the first
						 * entry in the vtbl[]
						 */
						e = new PtrExp(e.filename, e.lineNumber,  e);
						e.type = t.pointerTo(context);
						if (sym.isInterfaceDeclaration() != null) {
							if ((context.isD1() && sym.isCOMinterface()) || (context.isD2() && sym.isCPPinterface())) {
							    /* COM interface vtbl[]s are different in that the
								 * first entry is always pointer to QueryInterface().
								 * We can't get a .classinfo for it.
								 */
								if (context.acceptsErrors()) {
									if (context.isD1()) {
										context.acceptProblem(Problem.newSemanticTypeError(
												IProblem.NoClassInfoForComInterfaceObjects, this));
									} else {
										context.acceptProblem(Problem.newSemanticTypeError(
												IProblem.NoClassInfoForCppInterfaceObjects, this));
									}
								}
							}
						    /* 
						     * For an interface, the first entry in the vtbl[]
						     * is actually a pointer to an instance of struct Interface.
						     * The first member of Interface is the .classinfo,
						     * so add an extra pointer indirection.
						     */
							e.type = e.type.pointerTo(context);
							e = new PtrExp(e.filename, e.lineNumber,  e);
							e.type = t.pointerTo(context);
						}
						e = new PtrExp(e.filename, e.lineNumber,  e, t);
					}
					return e;
				}
				
				if (equals(ident, Id.__vptr))
				{   /* The pointer to the vtbl[]
				     * *cast(void***)e
				     */
					if (context.isD1()) {
						e = e.castTo(sc, context.Type_tvoidptr.pointerTo(context).pointerTo(context), context);
					} else {
						e = e.castTo(sc, context.Type_tvoidptr.invariantOf(context).pointerTo(context), context);
					}
				    e = new PtrExp(e.filename, e.lineNumber,  e);
				    e = e.semantic(sc, context);
				    return e;
				}

				if (equals(ident, Id.__monitor))
				{   /* The handle to the monitor (call it a void*)
				     * *(cast(void**)e + 1)
				     */
				    e = e.castTo(sc, context.Type_tvoidptr.pointerTo(context), context);
				    e = new AddExp(e.filename, e.lineNumber,  e, new IntegerExp(1));
				    e = new PtrExp(e.filename, e.lineNumber,  e);
				    e = e.semantic(sc, context);
				    return e;
				}
	
				if (equals(ident, Id.typeinfo)) {
					if (!context.global.params.useDeprecated) {
						if (context.acceptsErrors()) {
							context.acceptProblem(Problem.newSemanticTypeError(
									IProblem.DeprecatedProperty, ident, new String[] { "typeinfo",
											".typeid(type)" }));
						}
					}
					return getTypeInfo(sc, context);
				}
	
				if (equals(ident, Id.outer)
						&& null != sym.vthis) {
					s = sym.vthis;
				} else {
					if (context.isD2()) {
						if (!equals(ident, Id.__sizeof) && !equals(ident, Id.alignof) && !equals(ident, Id.init) && !equals(ident, Id.mangleof)
								&& !equals(ident, Id.stringof) && !equals(ident, Id.offsetof)) {
							/*
							 * See if we should forward to the alias this.
							 */
							if (sym.aliasthis != null) { 
								/*
								 * Rewrite e.ident as:
								 *  e.aliasthis.ident
								 */
								e = new DotIdExp(e.filename, e.lineNumber, e, sym.aliasthis.ident);
								e = new DotIdExp(e.filename, e.lineNumber, e, ident);
								return e.semantic(sc, context);
							}

							/*
							 * Look for overloaded opDot() to see if we should
							 * forward request to it.
							 */
							Dsymbol fd = search_function(sym, Id.opDot, context);
							if (fd != null) { /*
											 * Rewrite e.ident as:
											 * e.opId().ident
											 */
								e = build_overload(e.filename, e.lineNumber, sc, e, null, fd.ident, context);
								e = new DotIdExp(e.filename, e.lineNumber, e, ident);
								return e.semantic(sc, context);
							}
						}

					}
					return super.dotExp(sc, e, ident, context);
				}
			}
			
			// Descent: for binding resolution
			ident.setResolvedSymbol(s, context);
	
			if (null == s.isFuncDeclaration()) {	// because of overloading
				s.checkDeprecated(sc, context, ident);
			}
			
			s = s.toAlias(context);
			v = s.isVarDeclaration();
			if (context.isD1()) {
			    if (null != v && v.isConst() && v.type.toBasetype(context).ty != Tsarray) {
					ExpInitializer ei = v.getExpInitializer(context);
		
					if (null != ei) {
						e = ei.exp.copy(); // need to copy it if it's a StringExp
						e = e.semantic(sc, context);
						return e;
					}
				}
			} else {
				if (v != null && !v.isDataseg(context)) {
					Expression ei = v.getConstInitializer(context);

					if (ei != null) {
						e = ei.copy(); // need to copy it if it's a StringExp
						e = e.semantic(sc, context);
						return e;
					}
				}
			}
	
			if (null != s.getType(context)) {
				return new TypeExp(e.filename, e.lineNumber,  s.getType(context));
			}
	
			EnumMember em = s.isEnumMember();
			if (null != em) {
				assert (null != em.value());
				return em.value().copy();
			}
	
			TemplateMixin tm = s.isTemplateMixin();
			if (null != tm) {
				Expression de_ = new DotExp(e.filename, e.lineNumber,  e, new ScopeExp(e.filename, e.lineNumber,  tm));
				de_.type = e.type;
				return de_;
			}
	
			TemplateDeclaration td = s.isTemplateDeclaration();
			if (null != td) {
				e = new DotTemplateExp(e.filename, e.lineNumber,  e, td);
				e.semantic(sc, context);
				return e;
			}
			
		    TemplateInstance ti = s.isTemplateInstance();
			if (ti != null) {
				if (0 == ti.semanticdone) {
					ti.semantic(sc, context);
				}
				s = ti.inst.toAlias(context);
				if (null == s.isTemplateInstance()) {
					// goto L1;
					gotoL1 = true;
					continue;
				}
				Expression de2 = new DotExp(e.filename, e.lineNumber,  e, new ScopeExp(e.filename, e.lineNumber,  ti));
				de2.type = e.type;
				return de2;
			}
		}
		
		if (context.isD2()) {
			OverloadSet o = s.isOverloadSet();
			if (o != null) {
				/*
				 * We really should allow this
				 */
				if (context.acceptsErrors()) {
					context.acceptProblem(Problem.newSemanticTypeError(IProblem.OverloadSetNotAllowedInStructDeclaration, this, e.toChars(context), ident
							.toChars()));
				}
				return new ErrorExp();
			}
		}

		d = s.isDeclaration();
		if (null == d) {
			if (context.acceptsErrors()) {
				context.acceptProblem(Problem.newSemanticTypeError(
						IProblem.SymbolDotSymbolIsNotADeclaration, this, new String[] { e.toChars(context), ident.toChars() }));
			}
			if (context.isD1()) {
				return new IntegerExp(e.filename, e.lineNumber,  1, Type.tint32);
			} else {
				return new ErrorExp();
			}
		}

		if (e.op == TOKtype) {
			VarExp ve;

			/* It's:
			 *    Class.d
			 */
			if (context.isD2() && d.isTupleDeclaration() != null) {
				e = new TupleExp(e.filename, e.lineNumber, d.isTupleDeclaration(), context);
				e = e.semantic(sc, context);
				return e;
			} else if (d.needThis()
					&& (null != hasThis(sc) || null == d.isFuncDeclaration())) {
				if (null != sc.func) {
					ClassDeclaration thiscd;
					thiscd = sc.func.toParent().isClassDeclaration();

					if (null != thiscd) {
						ClassDeclaration cd = e.type.isClassHandle();

						if (cd == thiscd) {
							e = new ThisExp(e.filename, e.lineNumber);
							e = new DotTypeExp(e.filename, e.lineNumber,  e, cd, context);
							de = new DotVarExp(e.filename, e.lineNumber,  e, d);
							e = de.semantic(sc, context);
							return e;
						} else if ((null == cd || !cd.isBaseOf(thiscd, null,
								context))
								&& null == d.isFuncDeclaration()) {
							if (context.acceptsErrors()) {
								context.acceptProblem(Problem.newSemanticTypeError(
										IProblem.ThisIsRequiredButIsNotABaseClassOf, this, new String[] { e.type.toChars(context), thiscd.toChars(context) }));
							}
						}
					}
				}

				de = new DotVarExp(e.filename, e.lineNumber,  new ThisExp(e.filename, e.lineNumber), d);
				e = de.semantic(sc, context);
				return e;
			} else if (context.isD1() && null != d.isTupleDeclaration()) {
				e = new TupleExp(e.filename, e.lineNumber,  d.isTupleDeclaration(), context);
				;
				e = e.semantic(sc, context);
				return e;
			} else {
				if (context.isD1()) {
					ve = new VarExp(e.filename, e.lineNumber,  d);
				} else {
					ve = new VarExp(e.filename, e.lineNumber,  d, true);
				}
			}
			return ve;
		}

		if (d.isDataseg(context)) {
			// (e, d)
			VarExp ve;

			accessCheck(sc, e, d, context);
			if (context.isD1()) {
				ve = new VarExp(e.filename, e.lineNumber,  d);
			} else {
				ve = new VarExp(e.filename, e.lineNumber,  d, true);
			}
			e = new CommaExp(e.filename, e.lineNumber,  e, ve);
			e.type = d.type;
			return e;
		}

		if (null != d.parent && null != d.toParent().isModule()) {
			// (e, d)
			VarExp ve;

			ve = new VarExp(e.filename, e.lineNumber,  d);
			e = new CommaExp(e.filename, e.lineNumber,  e, ve);
			e.type = d.type;
			return e;
		}

		de = new DotVarExp(e.filename, e.lineNumber,  e, d);
		de.ident = ident; // Descent: for better error reporting
		de.copySourceRange(e);
		return de.semantic(sc, context);
	}

	@Override
	public int getNodeType() {
		return TYPE_CLASS;
	}

	@Override
	public TypeInfoDeclaration getTypeInfoDeclaration(SemanticContext context) {
		if (sym.isInterfaceDeclaration() != null) {
			return new TypeInfoInterfaceDeclaration(this, context);
		} else {
			return new TypeInfoClassDeclaration(this, context);
		}
	}

	@Override
	public boolean hasPointers(SemanticContext context) {
		return true;
	}

	@Override
	public MATCH implicitConvTo(Type to, SemanticContext context) {
		MATCH m;
		
		if (context.isD1()) {
			if (same(this, to, context)) {
				return MATCHexact;
			}
		} else {
			m = constConv(to, context);
			if (m != MATCHnomatch)
				return m;
		}

		ClassDeclaration cdto = to.isClassHandle();
		if (cdto != null && cdto.isBaseOf(sym, null, context)) {
			return MATCHconvert;
		}

		if (context.global.params.Dversion == 1) {
			// Allow conversion to (void *)
			if (to.ty == Tpointer && to.nextOf().ty == Tvoid) {
				return MATCHconvert;
			}
		}
		
		if (context.isD2()) {
			m = MATCHnomatch;
			if (sym.aliasthis != null) {
				Declaration d = sym.aliasthis.isDeclaration();
				if (d != null) {
					// assert(d.type);
					Type t = d.type.addMod(mod, context);
					m = t.implicitConvTo(to, context);
				}
			}
		}

		return MATCHnomatch;
	}

	@Override
	public boolean isauto() {
		return sym.isauto;
	}

	@Override
	public boolean isBaseOf(Type type, int[] poffset, SemanticContext context) {
		if (type.ty == Tclass) {
			ClassDeclaration cd = ((TypeClass) type).sym;
			if (sym.isBaseOf(cd, poffset, context)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public ClassDeclaration isClassHandle() {
		return sym;
	}

	@Override
	public boolean isZeroInit(char[] filename, int lineNumber, SemanticContext context) {
		return true;
	}

	@Override
	public Type semantic(char[] filename, int lineNumber, Scope sc, SemanticContext context) {
		if (sym.scope != null) {
			sym.semantic(sym.scope, context);
		}
		return merge(context);
	}

	@Override
	public int size(char[] filename, int lineNumber, SemanticContext context) {
		return PTRSIZE;
	}

	@Override
	public Type syntaxCopy(SemanticContext context) {
		return this;
	}

	@Override
	public void toCBuffer2(OutBuffer buf, HdrGenState hgs, int mod, SemanticContext context) {
	    if (mod != this.mod) {
			toCBuffer3(buf, hgs, mod, context);
			return;
		}
		buf.writestring(sym.toChars(context));
	}

	@Override
	public String toChars(SemanticContext context) {
		if (context.isD2()) {
		    if (mod != 0)
		    	return super.toChars(context);
		}
		return sym.toPrettyChars(context);
	}

	@Override
	public void toDecoBuffer(OutBuffer buf, int flag, SemanticContext context) {
		String name = sym.mangle(context);
		Type_toDecoBuffer(buf, flag, context);
		buf.writestring(name);
	}

	@Override
	public Dsymbol toDsymbol(Scope sc, SemanticContext context) {
		return sym;
	}
	
	@Override
	public Type toHeadMutable(SemanticContext context) {
		return this;
	}
	
	@Override
	public IJavaElement__Marker getJavaElement() {
		return sym.getJavaElement();
	}
	
	@Override
	protected void appendSignature0(StringBuilder sb, int options) {
		sym.appendSignature(sb, options);
	}
	
	@Override
	public char[] identRep() {
		return sym.ident == null ? null : sym.ident.ident;
	}

}
